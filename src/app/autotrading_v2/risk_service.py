"""
Î¶¨Ïä§ÌÅ¨ Î∂ÑÏÑù ÏóêÏù¥Ï†ÑÌä∏ ÏÑúÎπÑÏä§
yfinance, LangChain, LangGraphÎ•º ÌôúÏö©Ìïú ÏãúÏû• Î¶¨Ïä§ÌÅ¨ Î∂ÑÏÑù
"""

import asyncio
import numpy as np

import pandas as pd
from typing import Dict, Any, Optional, Tuple, List
from datetime import datetime, timezone, timedelta
from src.config.setting import settings
# ÏÑ†ÌÉùÏ†Å import (Ìå®ÌÇ§ÏßÄÍ∞Ä ÏÑ§ÏπòÎêòÏßÄ ÏïäÏùÄ Í≤ΩÏö∞Î•º ÎåÄÎπÑ)
try:
    import yfinance as yf
    YFINANCE_AVAILABLE = True
except ImportError:
    YFINANCE_AVAILABLE = False
    yf = None

try:
    from scipy.stats import pearsonr
    SCIPY_AVAILABLE = True
except ImportError:
    SCIPY_AVAILABLE = False
    pearsonr = None

try:
    from sklearn.preprocessing import StandardScaler
    SKLEARN_AVAILABLE = True
except ImportError:
    SKLEARN_AVAILABLE = False
    StandardScaler = None

from src.common.utils.logger import set_logger
from src.app.autotrading_v2.risk_models import (
    RiskAnalysisRequest, RiskAnalysisResponse,
    MarketData, RiskIndicators, CorrelationAnalysis,
    AIAnalysis, Recommendations
)

logger = set_logger("risk_analysis")


class RiskAnalysisService:
    """Î¶¨Ïä§ÌÅ¨ Î∂ÑÏÑù ÏÑúÎπÑÏä§"""

    def __init__(self):
        """Ï¥àÍ∏∞Ìôî"""
        self.symbols = {
            'btc': 'BTC-USD',
            'nasdaq': '^IXIC',
            'dxy': 'DX-Y.NYB',
            'vix': '^VIX',
            'gold': 'GC=F'
        }

        # AI Î∂ÑÏÑùÏùÑ ÏúÑÌïú LangChain ÏÑ§Ï†ï
        self.use_ai_analysis = True
        try:
            from langchain_openai import ChatOpenAI
            from langchain_core.messages import HumanMessage, SystemMessage

            self.llm = ChatOpenAI(
                model="gpt-4o-mini",
                temperature=0.3,
                max_tokens=1000
            )
            logger.info("‚úÖ LangChain Ï¥àÍ∏∞Ìôî ÏôÑÎ£å")
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è LangChain Ï¥àÍ∏∞Ìôî Ïã§Ìå®: {str(e)}")
            self.use_ai_analysis = False
            self.llm = None

    async def analyze_risk(
        self,
        market: str,
        analysis_type: str = "daily",
        days_back: int = 90,
        personality: str = "neutral",
        include_analysis: bool = True
    ) -> Dict[str, Any]:
        """
        Ïû•Í∏∞ ÏãúÏû• ÌôòÍ≤Ω Î¶¨Ïä§ÌÅ¨ Î∂ÑÏÑù Ïã§Ìñâ

        Args:
            market: Î∂ÑÏÑùÌï† ÎßàÏºì (Ïòà: BTC/USDT)
            analysis_type: Î∂ÑÏÑù Ïú†Ìòï (daily, weekly)
            days_back: Ï°∞Ìöå Í∏∞Í∞Ñ (Ïùº) - Ïû•Í∏∞ Î∂ÑÏÑùÏö©
            personality: Ìà¨Ïûê ÏÑ±Ìñ• (conservative, neutral, aggressive)
            include_analysis: AI Î∂ÑÏÑù Ìè¨Ìï® Ïó¨Î∂Ä

        Returns:
            Dict[str, Any]: Ïû•Í∏∞ ÏãúÏû• ÌôòÍ≤Ω Î∂ÑÏÑù Í≤∞Í≥º
        """
        try:
            logger.info(f"üöÄ Ïû•Í∏∞ ÏãúÏû• ÌôòÍ≤Ω Î∂ÑÏÑù ÏãúÏûë: {market} | {analysis_type} | {days_back}Ïùº")

            # ===== 1Îã®Í≥Ñ: Ïû•Í∏∞ ÏãúÏû• ÌôòÍ≤Ω Îç∞Ïù¥ÌÑ∞ ÏàòÏßë =====
            market_data = await self._collect_market_data(days_back, analysis_type)

            # ===== 2Îã®Í≥Ñ: Î¶¨Ïä§ÌÅ¨ ÏßÄÌëú Í≥ÑÏÇ∞ =====
            risk_indicators = self._calculate_risk_indicators(market_data)

            # ===== 3Îã®Í≥Ñ: ÏÉÅÍ¥ÄÍ¥ÄÍ≥Ñ Î∂ÑÏÑù =====
            correlation_analysis = self._analyze_correlations(market_data)

            # ===== 4Îã®Í≥Ñ: AI Î∂ÑÏÑù Î∞è ÏöîÏïΩ =====
            ai_analysis = None
            if include_analysis and self.use_ai_analysis:
                try:
                    ai_analysis = await self._perform_ai_analysis(
                        market_data, risk_indicators, correlation_analysis
                    )
                except Exception as e:
                    logger.error(f"AI Î∂ÑÏÑù Ïã§Ìå®: {str(e)}")

            # ===== 5Îã®Í≥Ñ: ÏµúÏ¢Ö Î¶¨Ïä§ÌÅ¨ Î†àÎ≤® Í≤∞Ï†ï (personality Í≥†Î†§) =====
            market_risk_level, risk_off_signal, confidence = self._determine_risk_level(
                risk_indicators, correlation_analysis, personality
            )

            # ===== 6Îã®Í≥Ñ: Î¶¨Ïä§ÌÅ¨ ÏóêÏù¥Ï†ÑÌä∏Îäî Ìà¨Ïûê Í∂åÏû•ÏÇ¨Ìï≠ÏùÑ Ï†úÍ≥µÌïòÏßÄ ÏïäÏùå =====
            recommendations = None

            # ===== 7Îã®Í≥Ñ: Í≤∞Í≥º Íµ¨ÏÑ± =====
            result = {
                "status": "success",
                "market": market,
                "timestamp": datetime.now(timezone.utc).isoformat(),

                # ÏãúÏû• Îç∞Ïù¥ÌÑ∞
                "market_data": market_data.dict(),

                # Î¶¨Ïä§ÌÅ¨ ÏßÄÌëú
                "risk_indicators": risk_indicators.dict(),

                # ÏÉÅÍ¥ÄÍ¥ÄÍ≥Ñ Î∂ÑÏÑù
                "correlation_analysis": correlation_analysis.dict(),

                # AI Î∂ÑÏÑù
                "ai_analysis": ai_analysis.dict() if ai_analysis else None,

                # ÏµúÏ¢Ö Î¶¨Ïä§ÌÅ¨ Î†àÎ≤®
                "market_risk_level": market_risk_level,
                "risk_off_signal": risk_off_signal,
                "confidence": confidence,

                # Í∂åÏû•ÏÇ¨Ìï≠ (Î¶¨Ïä§ÌÅ¨ ÏóêÏù¥Ï†ÑÌä∏Îäî Ï†úÍ≥µÌïòÏßÄ ÏïäÏùå)
                "recommendations": None,

                # Î©îÌÉÄÎç∞Ïù¥ÌÑ∞
                "metadata": {
                    "analysis_period": f"{days_back}Ïùº",
                    "analysis_type": analysis_type,
                    "ai_analysis_included": ai_analysis is not None,
                    "data_points": 0  # MarketDataÎäî Îã®Ïùº Í∞íÏù¥ÎØÄÎ°ú Í∏∏Ïù¥ Í∞úÎÖêÏù¥ ÏóÜÏùå
                }
            }

            logger.info("üéâ Î¶¨Ïä§ÌÅ¨ Î∂ÑÏÑù ÏôÑÎ£å!")
            logger.info(f"üìä Î¶¨Ïä§ÌÅ¨ Î†àÎ≤®: {market_risk_level} | Risk-Off: {risk_off_signal} | Ïã†Î¢∞ÎèÑ: {confidence:.2f}")

            return result

        except Exception as e:
            logger.error(f"Î¶¨Ïä§ÌÅ¨ Î∂ÑÏÑù Ïã§Ìå®: {str(e)}")
            return {
                "status": "error",
                "market": market,
                "timestamp": datetime.now(timezone.utc).isoformat(),
                "market_data": {},
                "risk_indicators": {},
                "correlation_analysis": {},
                "ai_analysis": None,
                "market_risk_level": "UNKNOWN",
                "risk_off_signal": False,
                "confidence": 0.0,
                "recommendations": None,
                "metadata": {"error": str(e)}
            }

    async def _collect_market_data(self, days_back: int, analysis_type: str = "daily") -> MarketData:
        """Ïû•Í∏∞ ÏãúÏû• ÌôòÍ≤Ω Îç∞Ïù¥ÌÑ∞ ÏàòÏßë"""
        try:
            # Ïû•Í∏∞ Î∂ÑÏÑùÏùÑ ÏúÑÌï¥ Îçî Í∏¥ Í∏∞Í∞Ñ ÏÑ§Ï†ï
            if analysis_type == "weekly":
                # Ï£ºÎ¥â Î∂ÑÏÑù: ÏµúÏÜå 6Í∞úÏõî Îç∞Ïù¥ÌÑ∞
                days_back = max(days_back, 180)
            else:
                # ÏùºÎ¥â Î∂ÑÏÑù: ÏµúÏÜå 3Í∞úÏõî Îç∞Ïù¥ÌÑ∞
                days_back = max(days_back, 90)

            end_date = datetime.now()
            start_date = end_date - timedelta(days=days_back)

            # Î≥ëÎ†¨Î°ú Îç∞Ïù¥ÌÑ∞ ÏàòÏßë
            tasks = []
            for symbol_name, symbol in self.symbols.items():
                task = self._fetch_yfinance_data(symbol, start_date, end_date)
                tasks.append((symbol_name, task))

            # Î™®Îì† Îç∞Ïù¥ÌÑ∞ ÏàòÏßë ÏôÑÎ£å ÎåÄÍ∏∞
            results = {}
            for symbol_name, task in tasks:
                try:
                    data = await task
                    results[symbol_name] = data
                except Exception as e:
                    logger.warning(f"‚ö†Ô∏è {symbol_name} Îç∞Ïù¥ÌÑ∞ ÏàòÏßë Ïã§Ìå®: {str(e)}")
                    results[symbol_name] = None

            # MarketData Í∞ùÏ≤¥ ÏÉùÏÑ±
            market_data = self._create_market_data_object(results)
            return market_data

        except Exception as e:
            logger.error(f"ÏãúÏû• Îç∞Ïù¥ÌÑ∞ ÏàòÏßë Ïã§Ìå®: {str(e)}")
            raise

    async def _fetch_yfinance_data(self, symbol: str, start_date: datetime, end_date: datetime) -> Optional[pd.DataFrame]:
        """yfinanceÎ•º ÏÇ¨Ïö©Ìïú Îç∞Ïù¥ÌÑ∞ ÏàòÏßë"""
        if not YFINANCE_AVAILABLE:
            logger.warning(f"‚ö†Ô∏è yfinanceÍ∞Ä ÏÑ§ÏπòÎêòÏßÄ ÏïäÏùå")
            return None

        try:
            # ÎπÑÎèôÍ∏∞ Ï≤òÎ¶¨Î•º ÏúÑÌï¥ Î≥ÑÎèÑ Ïä§Î†àÎìúÏóêÏÑú Ïã§Ìñâ
            loop = asyncio.get_event_loop()
            data = await loop.run_in_executor(
                None,
                lambda: yf.download(symbol, start=start_date, end=end_date, progress=False)
            )

            if data.empty:
                logger.warning(f"‚ö†Ô∏è {symbol} Îç∞Ïù¥ÌÑ∞Í∞Ä ÎπÑÏñ¥ÏûàÏùå")
                return None

            return data

        except Exception as e:
            logger.error(f"yfinance Îç∞Ïù¥ÌÑ∞ ÏàòÏßë Ïã§Ìå® ({symbol}): {str(e)}")
            return None

    def _create_market_data_object(self, results: Dict[str, Optional[pd.DataFrame]]) -> MarketData:
        """ÏàòÏßëÎêú Îç∞Ïù¥ÌÑ∞Î°ú MarketData Í∞ùÏ≤¥ ÏÉùÏÑ±"""
        try:
            # Í∞Å Ïã¨Î≥ºÎ≥ÑÎ°ú ÏµúÏã† Í∞ÄÍ≤©Í≥º Î≥ÄÌôîÏú® Í≥ÑÏÇ∞
            data_dict = {}

            for symbol_name, df in results.items():
                if df is not None and not df.empty:
                    # ÏµúÏã† Í∞ÄÍ≤© (Close)
                    current_price = float(df['Close'].iloc[-1])

                    # 24ÏãúÍ∞Ñ Î≥ÄÌôîÏú® (ÎßàÏßÄÎßâ 2Í∞ú Îç∞Ïù¥ÌÑ∞ Ìè¨Ïù∏Ìä∏ Í∏∞Ï§Ä)
                    if len(df) >= 2:
                        prev_price = float(df['Close'].iloc[-2])
                        change_24h = ((current_price - prev_price) / prev_price) * 100
                    else:
                        change_24h = 0.0

                    data_dict[symbol_name] = {
                        'price': current_price,
                        'change_24h': change_24h,
                        'data': df
                    }
                else:
                    # Í∏∞Î≥∏Í∞í ÏÑ§Ï†ï
                    data_dict[symbol_name] = {
                        'price': 0.0,
                        'change_24h': 0.0,
                        'data': None
                    }

            # MarketData Í∞ùÏ≤¥ ÏÉùÏÑ±
            return MarketData(
                btc_price=data_dict['btc']['price'],
                btc_change_24h=data_dict['btc']['change_24h'],
                btc_volatility=self._calculate_volatility(data_dict['btc']['data']),

                nasdaq_price=data_dict['nasdaq']['price'],
                nasdaq_change_24h=data_dict['nasdaq']['change_24h'],

                dxy_price=data_dict['dxy']['price'],
                dxy_change_24h=data_dict['dxy']['change_24h'],

                vix_price=data_dict['vix']['price'],
                vix_change_24h=data_dict['vix']['change_24h'],

                gold_price=data_dict['gold']['price'],
                gold_change_24h=data_dict['gold']['change_24h']
            )

        except Exception as e:
            logger.error(f"MarketData Í∞ùÏ≤¥ ÏÉùÏÑ± Ïã§Ìå®: {str(e)}")
            # Í∏∞Î≥∏Í∞íÏúºÎ°ú ÏÉùÏÑ±
            return MarketData(
                btc_price=0.0, btc_change_24h=0.0, btc_volatility=0.0,
                nasdaq_price=0.0, nasdaq_change_24h=0.0,
                dxy_price=0.0, dxy_change_24h=0.0,
                vix_price=0.0, vix_change_24h=0.0,
                gold_price=0.0, gold_change_24h=0.0
            )

    def _calculate_volatility(self, df: Optional[pd.DataFrame]) -> float:
        """Î≥ÄÎèôÏÑ± Í≥ÑÏÇ∞ (Ïó∞Í∞ÑÌôîÎêú ÌëúÏ§ÄÌé∏Ï∞®)"""
        if df is None or df.empty or len(df) < 2:
            return 0.0

        try:
            # ÏùºÏùº ÏàòÏùµÎ•† Í≥ÑÏÇ∞
            returns = df['Close'].pct_change().dropna()

            # Ïó∞Í∞ÑÌôîÎêú Î≥ÄÎèôÏÑ± (252 Í±∞ÎûòÏùº Í∏∞Ï§Ä)
            volatility = returns.std() * np.sqrt(252) * 100
            return float(volatility)

        except Exception as e:
            logger.error(f"Î≥ÄÎèôÏÑ± Í≥ÑÏÇ∞ Ïã§Ìå®: {str(e)}")
            return 0.0

    def _calculate_risk_indicators(self, market_data: MarketData) -> RiskIndicators:
        """Î¶¨Ïä§ÌÅ¨ ÏßÄÌëú Í≥ÑÏÇ∞"""
        try:
            # ÎπÑÌä∏ÏΩîÏù∏ Î≥ÄÎèôÏÑ± ÏßÄÌëú (Ïã§Ï†úÎ°úÎäî Îçî Î≥µÏû°Ìïú Í≥ÑÏÇ∞Ïù¥ ÌïÑÏöîÌïòÏßÄÎßå Ïó¨Í∏∞ÏÑúÎäî Í∞ÑÎã®Ìûà)
            btc_vol_7d = market_data.btc_volatility  # Ïã§Ï†úÎ°úÎäî 7Ïùº Î≥ÄÎèôÏÑ± Í≥ÑÏÇ∞ ÌïÑÏöî
            btc_vol_30d = market_data.btc_volatility * 1.2  # Ïã§Ï†úÎ°úÎäî 30Ïùº Î≥ÄÎèôÏÑ± Í≥ÑÏÇ∞ ÌïÑÏöî
            btc_vol_percentile = min(100, max(0, (btc_vol_30d - 20) / 40 * 100))  # 20-60% Î≤îÏúÑÎ•º 0-100ÏúºÎ°ú Ï†ïÍ∑úÌôî

            # VIX Î†àÎ≤® Î∞è Î∞±Î∂ÑÏúÑÏàò
            vix_level = market_data.vix_price
            vix_percentile = min(100, max(0, (vix_level - 10) / 30 * 100))  # 10-40 Î≤îÏúÑÎ•º 0-100ÏúºÎ°ú Ï†ïÍ∑úÌôî

            # Îã¨Îü¨ Ïù∏Îç±Ïä§ Î†àÎ≤® Î∞è Î∞±Î∂ÑÏúÑÏàò
            dxy_level = market_data.dxy_price
            dxy_percentile = min(100, max(0, (dxy_level - 90) / 20 * 100))  # 90-110 Î≤îÏúÑÎ•º 0-100ÏúºÎ°ú Ï†ïÍ∑úÌôî

            # Í∏à Î≥ÄÎèôÏÑ± Î∞è Î∞±Î∂ÑÏúÑÏàò (Í∞ÑÎã®Ìïú Ï∂îÏ†ï)
            gold_vol = abs(market_data.gold_change_24h) * 2  # 24ÏãúÍ∞Ñ Î≥ÄÌôîÏú®Ïùò 2Î∞∞Î•º Î≥ÄÎèôÏÑ±ÏúºÎ°ú Ï∂îÏ†ï
            gold_percentile = min(100, max(0, (market_data.gold_price - 1500) / 500 * 100))  # 1500-2000 Î≤îÏúÑÎ•º 0-100ÏúºÎ°ú Ï†ïÍ∑úÌôî

            # Ï¢ÖÌï© Î¶¨Ïä§ÌÅ¨ Ï†êÏàò Í≥ÑÏÇ∞ (Í∞ÄÏ§ë ÌèâÍ∑†)
            overall_risk_score = (
                btc_vol_percentile * 0.3 +  # ÎπÑÌä∏ÏΩîÏù∏ Î≥ÄÎèôÏÑ± 30%
                vix_percentile * 0.25 +    # VIX 25%
                dxy_percentile * 0.2 +     # Îã¨Îü¨ Ïù∏Îç±Ïä§ 20%
                gold_percentile * 0.15 +   # Í∏à 15%
                abs(market_data.btc_change_24h) * 0.1  # ÎπÑÌä∏ÏΩîÏù∏ ÏùºÏùº Î≥ÄÌôîÏú® 10%
            )

            return RiskIndicators(
                btc_volatility_7d=btc_vol_7d,
                btc_volatility_30d=btc_vol_30d,
                btc_volatility_percentile=btc_vol_percentile,
                vix_level=vix_level,
                vix_percentile=vix_percentile,
                dxy_level=dxy_level,
                dxy_percentile=dxy_percentile,
                gold_volatility=gold_vol,
                gold_percentile=gold_percentile,
                overall_risk_score=overall_risk_score
            )

        except Exception as e:
            logger.error(f"Î¶¨Ïä§ÌÅ¨ ÏßÄÌëú Í≥ÑÏÇ∞ Ïã§Ìå®: {str(e)}")
            # Í∏∞Î≥∏Í∞í Î∞òÌôò
            return RiskIndicators(
                btc_volatility_7d=0.0, btc_volatility_30d=0.0, btc_volatility_percentile=50.0,
                vix_level=20.0, vix_percentile=50.0,
                dxy_level=100.0, dxy_percentile=50.0,
                gold_volatility=0.0, gold_percentile=50.0,
                overall_risk_score=50.0
            )

    def _analyze_correlations(self, market_data: MarketData) -> CorrelationAnalysis:
        """ÏÉÅÍ¥ÄÍ¥ÄÍ≥Ñ Î∂ÑÏÑù"""
        try:
            # Ïã§Ï†ú ÏãúÏû• Îç∞Ïù¥ÌÑ∞Î•º Í∏∞Î∞òÏúºÎ°ú Ìïú Í∞ÑÎã®Ìïú ÏÉÅÍ¥ÄÍ¥ÄÍ≥Ñ Ï∂îÏ†ï
            # Ïã§Ï†úÎ°úÎäî Îçî ÎßéÏùÄ ÏãúÍ≥ÑÏó¥ Îç∞Ïù¥ÌÑ∞Í∞Ä ÌïÑÏöîÌïòÏßÄÎßå, ÌòÑÏû¨Îäî 24ÏãúÍ∞Ñ Î≥ÄÌôîÏú®ÏùÑ Í∏∞Î∞òÏúºÎ°ú Ï∂îÏ†ï

            # ÎπÑÌä∏ÏΩîÏù∏Í≥º Ï£ºÏöî ÏûêÏÇ∞Ïùò ÏÉÅÍ¥ÄÍ¥ÄÍ≥Ñ (Î≥ÄÌôîÏú® Í∏∞Î∞ò Ï∂îÏ†ï)
            btc_change = market_data.btc_change_24h
            nasdaq_change = market_data.nasdaq_change_24h
            dxy_change = market_data.dxy_change_24h
            vix_change = market_data.vix_change_24h
            gold_change = market_data.gold_change_24h

            # Î≥ÄÌôîÏú®Ïùò Î∂ÄÌò∏Î•º Í∏∞Î∞òÏúºÎ°ú Ìïú Í∞ÑÎã®Ìïú ÏÉÅÍ¥ÄÍ¥ÄÍ≥Ñ Ï∂îÏ†ï
            btc_nasdaq_corr = self._estimate_correlation(btc_change, nasdaq_change)
            btc_dxy_corr = self._estimate_correlation(btc_change, dxy_change)
            btc_vix_corr = self._estimate_correlation(btc_change, vix_change)
            btc_gold_corr = self._estimate_correlation(btc_change, gold_change)

            # Ï£ºÏöî ÏûêÏÇ∞ Í∞Ñ ÏÉÅÍ¥ÄÍ¥ÄÍ≥Ñ
            nasdaq_dxy_corr = self._estimate_correlation(nasdaq_change, dxy_change)
            nasdaq_vix_corr = self._estimate_correlation(nasdaq_change, vix_change)
            dxy_vix_corr = self._estimate_correlation(dxy_change, vix_change)

            # ÏÉÅÍ¥ÄÍ¥ÄÍ≥Ñ Ìï¥ÏÑù
            correlation_summary = self._interpret_correlations(
                btc_nasdaq_corr, btc_dxy_corr, btc_vix_corr, btc_gold_corr,
                nasdaq_dxy_corr, nasdaq_vix_corr, dxy_vix_corr
            )

            # Risk-Off Ïã†Ìò∏ ÏßÄÌëúÎì§
            risk_off_indicators = self._identify_risk_off_indicators(
                btc_nasdaq_corr, btc_dxy_corr, btc_vix_corr,
                nasdaq_dxy_corr, nasdaq_vix_corr, dxy_vix_corr
            )

            return CorrelationAnalysis(
                btc_nasdaq_correlation=btc_nasdaq_corr,
                btc_dxy_correlation=btc_dxy_corr,
                btc_vix_correlation=btc_vix_corr,
                btc_gold_correlation=btc_gold_corr,
                nasdaq_dxy_correlation=nasdaq_dxy_corr,
                nasdaq_vix_correlation=nasdaq_vix_corr,
                dxy_vix_correlation=dxy_vix_corr,
                correlation_summary=correlation_summary,
                risk_off_indicators=risk_off_indicators
            )

        except Exception as e:
            logger.error(f"ÏÉÅÍ¥ÄÍ¥ÄÍ≥Ñ Î∂ÑÏÑù Ïã§Ìå®: {str(e)}")
            # Í∏∞Î≥∏Í∞í Î∞òÌôò
            return CorrelationAnalysis(
                btc_nasdaq_correlation=0.0, btc_dxy_correlation=0.0,
                btc_vix_correlation=0.0, btc_gold_correlation=0.0,
                nasdaq_dxy_correlation=0.0, nasdaq_vix_correlation=0.0,
                dxy_vix_correlation=0.0,
                correlation_summary="ÏÉÅÍ¥ÄÍ¥ÄÍ≥Ñ Î∂ÑÏÑù Ïã§Ìå®",
                risk_off_indicators=[]
            )

    def _interpret_correlations(
        self, btc_nasdaq: float, btc_dxy: float, btc_vix: float, btc_gold: float,
        nasdaq_dxy: float, nasdaq_vix: float, dxy_vix: float
    ) -> str:
        """ÏÉÅÍ¥ÄÍ¥ÄÍ≥Ñ Ìï¥ÏÑù"""
        interpretations = []

        if abs(btc_nasdaq) > 0.5:
            direction = "ÏñëÏùò" if btc_nasdaq > 0 else "ÏùåÏùò"
            strength = "Í∞ïÌïú" if abs(btc_nasdaq) > 0.7 else "Ï§ëÍ∞Ñ"
            interpretations.append(f"ÎπÑÌä∏ÏΩîÏù∏-ÎÇòÏä§Îã•: {strength} {direction} ÏÉÅÍ¥ÄÍ¥ÄÍ≥Ñ")

        if abs(btc_dxy) > 0.5:
            direction = "ÏñëÏùò" if btc_dxy > 0 else "ÏùåÏùò"
            strength = "Í∞ïÌïú" if abs(btc_dxy) > 0.7 else "Ï§ëÍ∞Ñ"
            interpretations.append(f"ÎπÑÌä∏ÏΩîÏù∏-Îã¨Îü¨Ïù∏Îç±Ïä§: {strength} {direction} ÏÉÅÍ¥ÄÍ¥ÄÍ≥Ñ")

        if abs(nasdaq_vix) > 0.5:
            direction = "ÏñëÏùò" if nasdaq_vix > 0 else "ÏùåÏùò"
            strength = "Í∞ïÌïú" if abs(nasdaq_vix) > 0.7 else "Ï§ëÍ∞Ñ"
            interpretations.append(f"ÎÇòÏä§Îã•-VIX: {strength} {direction} ÏÉÅÍ¥ÄÍ¥ÄÍ≥Ñ")

        if not interpretations:
            return "Ï£ºÏöî ÏûêÏÇ∞ Í∞Ñ ÏÉÅÍ¥ÄÍ¥ÄÍ≥ÑÍ∞Ä ÏïΩÌïòÍ±∞ÎÇò Ï§ëÎ¶ΩÏ†ÅÏûÖÎãàÎã§."

        return " | ".join(interpretations)

    def _identify_risk_off_indicators(
        self, btc_nasdaq: float, btc_dxy: float, btc_vix: float,
        nasdaq_dxy: float, nasdaq_vix: float, dxy_vix: float
    ) -> List[str]:
        """Risk-Off Ïã†Ìò∏ ÏßÄÌëú ÏãùÎ≥Ñ"""
        indicators = []

        # VIXÍ∞Ä ÎÜíÍ≥† ÎÇòÏä§Îã•Í≥º Í∞ïÌïú ÏùåÏùò ÏÉÅÍ¥ÄÍ¥ÄÍ≥Ñ
        if nasdaq_vix < -0.6:
            indicators.append("VIX ÏÉÅÏäπÍ≥º ÎÇòÏä§Îã• ÌïòÎùΩ ÎèôÎ∞ò")

        # Îã¨Îü¨ Í∞ïÏÑ∏ÏôÄ ÎπÑÌä∏ÏΩîÏù∏ ÏïΩÏÑ∏
        if btc_dxy < -0.5:
            indicators.append("Îã¨Îü¨ Í∞ïÏÑ∏ÏôÄ ÎπÑÌä∏ÏΩîÏù∏ ÏïΩÏÑ∏")

        # ÎπÑÌä∏ÏΩîÏù∏Í≥º ÎÇòÏä§Îã•Ïùò Í∞ïÌïú ÏñëÏùò ÏÉÅÍ¥ÄÍ¥ÄÍ≥Ñ (ÏúÑÌóò ÏûêÏÇ∞ ÎèôÎ∞ò ÌïòÎùΩ)
        if btc_nasdaq > 0.6:
            indicators.append("ÎπÑÌä∏ÏΩîÏù∏Í≥º ÎÇòÏä§Îã• Í∞ïÌïú ÏñëÏùò ÏÉÅÍ¥ÄÍ¥ÄÍ≥Ñ")

        # VIXÏôÄ Îã¨Îü¨Ïùò ÏñëÏùò ÏÉÅÍ¥ÄÍ¥ÄÍ≥Ñ (ÏïàÏ†ÑÏûêÏÇ∞ ÏÑ†Ìò∏)
        if dxy_vix > 0.5:
            indicators.append("VIX ÏÉÅÏäπÍ≥º Îã¨Îü¨ Í∞ïÏÑ∏ ÎèôÎ∞ò")

        return indicators

    def _estimate_correlation(self, change1: float, change2: float) -> float:
        """Î≥ÄÌôîÏú®ÏùÑ Í∏∞Î∞òÏúºÎ°ú Ìïú Í∞ÑÎã®Ìïú ÏÉÅÍ¥ÄÍ¥ÄÍ≥Ñ Ï∂îÏ†ï"""
        try:
            # Îëò Îã§ 0Ïóê Í∞ÄÍπåÏö∞Î©¥ ÏÉÅÍ¥ÄÍ¥ÄÍ≥Ñ ÏóÜÏùå
            if abs(change1) < 0.1 and abs(change2) < 0.1:
                return 0.0

            # Î∂ÄÌò∏Í∞Ä Í∞ôÏúºÎ©¥ ÏñëÏùò ÏÉÅÍ¥ÄÍ¥ÄÍ≥Ñ, Îã§Î•¥Î©¥ ÏùåÏùò ÏÉÅÍ¥ÄÍ¥ÄÍ≥Ñ
            if (change1 > 0 and change2 > 0) or (change1 < 0 and change2 < 0):
                # Î≥ÄÌôîÏú®Ïùò ÌÅ¨Í∏∞Ïóê Îî∞Îùº ÏÉÅÍ¥ÄÍ¥ÄÍ≥Ñ Í∞ïÎèÑ Í≤∞Ï†ï
                magnitude = min(abs(change1), abs(change2)) / max(abs(change1), abs(change2))
                return min(0.8, magnitude * 0.5)  # ÏµúÎåÄ 0.8
            else:
                # Î≥ÄÌôîÏú®Ïùò ÌÅ¨Í∏∞Ïóê Îî∞Îùº ÏÉÅÍ¥ÄÍ¥ÄÍ≥Ñ Í∞ïÎèÑ Í≤∞Ï†ï
                magnitude = min(abs(change1), abs(change2)) / max(abs(change1), abs(change2))
                return max(-0.8, -magnitude * 0.5)  # ÏµúÏÜå -0.8

        except Exception as e:
            logger.error(f"ÏÉÅÍ¥ÄÍ¥ÄÍ≥Ñ Ï∂îÏ†ï Ïã§Ìå®: {str(e)}")
            return 0.0

    async def _perform_ai_analysis(
        self, market_data: MarketData, risk_indicators: RiskIndicators,
        correlation_analysis: CorrelationAnalysis
    ) -> Optional[AIAnalysis]:
        """AI Î∂ÑÏÑù ÏàòÌñâ"""
        if not self.use_ai_analysis or self.llm is None:
            return None

        try:
            # Î∂ÑÏÑùÌï† Îç∞Ïù¥ÌÑ∞ Ï§ÄÎπÑ
            analysis_data = {
                "market_data": market_data.dict(),
                "risk_indicators": risk_indicators.dict(),
                "correlation_analysis": correlation_analysis.dict()
            }

            # ÌîÑÎ°¨ÌîÑÌä∏ ÏÉùÏÑ±
            prompt = self._create_analysis_prompt(analysis_data)

            # AI Î∂ÑÏÑù Ïã§Ìñâ
            try:
                from langchain_core.messages import HumanMessage, SystemMessage
                messages = [
                    SystemMessage(content="ÎãπÏã†ÏùÄ Ï†ÑÎ¨∏Ï†ÅÏù∏ Í∏àÏúµ Î¶¨Ïä§ÌÅ¨ Î∂ÑÏÑùÍ∞ÄÏûÖÎãàÎã§. Ï£ºÏñ¥ÏßÑ ÏãúÏû• Îç∞Ïù¥ÌÑ∞Î•º Î∂ÑÏÑùÌïòÏó¨ Ìà¨ÏûêÏûêÏóêÍ≤å ÎèÑÏõÄÏù¥ ÎêòÎäî Ïù∏ÏÇ¨Ïù¥Ìä∏Î•º Ï†úÍ≥µÌï¥Ï£ºÏÑ∏Ïöî."),
                    HumanMessage(content=prompt)
                ]
            except ImportError:
                # LangChain Î©îÏãúÏßÄ ÌÅ¥ÎûòÏä§Í∞Ä ÏóÜÎäî Í≤ΩÏö∞ Í∞ÑÎã®Ìïú ÎîïÏÖîÎÑàÎ¶¨ ÏÇ¨Ïö©
                messages = [
                    {"role": "system", "content": "ÎãπÏã†ÏùÄ Ï†ÑÎ¨∏Ï†ÅÏù∏ Í∏àÏúµ Î¶¨Ïä§ÌÅ¨ Î∂ÑÏÑùÍ∞ÄÏûÖÎãàÎã§. Ï£ºÏñ¥ÏßÑ ÏãúÏû• Îç∞Ïù¥ÌÑ∞Î•º Î∂ÑÏÑùÌïòÏó¨ Ìà¨ÏûêÏûêÏóêÍ≤å ÎèÑÏõÄÏù¥ ÎêòÎäî Ïù∏ÏÇ¨Ïù¥Ìä∏Î•º Ï†úÍ≥µÌï¥Ï£ºÏÑ∏Ïöî."},
                    {"role": "user", "content": prompt}
                ]

            response = await self.llm.ainvoke(messages)
            analysis_text = response.content

            # AI Î∂ÑÏÑù Í≤∞Í≥º ÌååÏã±
            market_summary = self._extract_section(analysis_text, "ÏãúÏû• ÏöîÏïΩ")
            risk_assessment = self._extract_section(analysis_text, "Î¶¨Ïä§ÌÅ¨ ÌèâÍ∞Ä")
            key_risks = self._extract_list(analysis_text, "Ï£ºÏöî Î¶¨Ïä§ÌÅ¨")
            opportunities = self._extract_list(analysis_text, "Ìà¨Ïûê Í∏∞Ìöå")
            risk_summary = self._extract_section(analysis_text, "Î¶¨Ïä§ÌÅ¨ ÏöîÏïΩ")

            return AIAnalysis(
                market_summary=market_summary,
                risk_assessment=risk_assessment,
                key_risks=key_risks,
                opportunities=opportunities,
                recommendations=risk_summary,
                confidence=0.8
            )

        except Exception as e:
            logger.error(f"AI Î∂ÑÏÑù Ïã§Ìå®: {str(e)}")
            import traceback
            logger.error(f"AI Î∂ÑÏÑù Ïã§Ìå® ÏÉÅÏÑ∏: {traceback.format_exc()}")
            return None

    def _create_analysis_prompt(self, data: Dict[str, Any]) -> str:
        """AI Î∂ÑÏÑùÏùÑ ÏúÑÌïú ÌîÑÎ°¨ÌîÑÌä∏ ÏÉùÏÑ±"""
        return f"""
Îã§Ïùå ÏãúÏû• Îç∞Ïù¥ÌÑ∞Î•º Î∂ÑÏÑùÌïòÏó¨ Ìà¨ÏûêÏûêÏóêÍ≤å ÎèÑÏõÄÏù¥ ÎêòÎäî Ïù∏ÏÇ¨Ïù¥Ìä∏Î•º Ï†úÍ≥µÌï¥Ï£ºÏÑ∏Ïöî:

=== ÏãúÏû• Îç∞Ïù¥ÌÑ∞ ===
- ÎπÑÌä∏ÏΩîÏù∏ Í∞ÄÍ≤©: ${data['market_data']['btc_price']:,.2f} ({data['market_data']['btc_change_24h']:+.2f}%)
- ÎÇòÏä§Îã•: {data['market_data']['nasdaq_price']:,.2f} ({data['market_data']['nasdaq_change_24h']:+.2f}%)
- Îã¨Îü¨ Ïù∏Îç±Ïä§: {data['market_data']['dxy_price']:.2f} ({data['market_data']['dxy_change_24h']:+.2f}%)
- VIX: {data['market_data']['vix_price']:.2f} ({data['market_data']['vix_change_24h']:+.2f}%)
- Í∏à: ${data['market_data']['gold_price']:,.2f} ({data['market_data']['gold_change_24h']:+.2f}%)

=== Î¶¨Ïä§ÌÅ¨ ÏßÄÌëú ===
- ÎπÑÌä∏ÏΩîÏù∏ Î≥ÄÎèôÏÑ±: {data['risk_indicators']['btc_volatility_30d']:.2f}%
- VIX Î†àÎ≤®: {data['risk_indicators']['vix_level']:.2f}
- Îã¨Îü¨ Ïù∏Îç±Ïä§: {data['risk_indicators']['dxy_level']:.2f}
- Ï¢ÖÌï© Î¶¨Ïä§ÌÅ¨ Ï†êÏàò: {data['risk_indicators']['overall_risk_score']:.1f}/100

=== ÏÉÅÍ¥ÄÍ¥ÄÍ≥Ñ Î∂ÑÏÑù ===
- ÎπÑÌä∏ÏΩîÏù∏-ÎÇòÏä§Îã•: {data['correlation_analysis']['btc_nasdaq_correlation']:.2f}
- ÎπÑÌä∏ÏΩîÏù∏-Îã¨Îü¨Ïù∏Îç±Ïä§: {data['correlation_analysis']['btc_dxy_correlation']:.2f}
- ÎπÑÌä∏ÏΩîÏù∏-VIX: {data['correlation_analysis']['btc_vix_correlation']:.2f}
- ÎÇòÏä§Îã•-VIX: {data['correlation_analysis']['nasdaq_vix_correlation']:.2f}

Îã§Ïùå ÌòïÏãùÏúºÎ°ú Î∂ÑÏÑù Í≤∞Í≥ºÎ•º Ï†úÍ≥µÌï¥Ï£ºÏÑ∏Ïöî:

**ÏãúÏû• ÏöîÏïΩ:**
[ÌòÑÏû¨ ÏãúÏû• ÏÉÅÌô©Ïóê ÎåÄÌïú Í∞ÑÎã®Ìïú ÏöîÏïΩ]

**Î¶¨Ïä§ÌÅ¨ ÌèâÍ∞Ä:**
[ÌòÑÏû¨ ÏãúÏû•Ïùò Î¶¨Ïä§ÌÅ¨ ÏàòÏ§ÄÍ≥º Ï£ºÏöî ÏúÑÌóò ÏöîÏù∏]

**Ï£ºÏöî Î¶¨Ïä§ÌÅ¨:**
- [Î¶¨Ïä§ÌÅ¨ 1]
- [Î¶¨Ïä§ÌÅ¨ 2]
- [Î¶¨Ïä§ÌÅ¨ 3]

**Ìà¨Ïûê Í∏∞Ìöå:**
- [Í∏∞Ìöå 1]
- [Í∏∞Ìöå 2]
- [Í∏∞Ìöå 3]

**Î¶¨Ïä§ÌÅ¨ ÏöîÏïΩ:**
[ÌòÑÏû¨ ÏãúÏû•Ïùò Ï£ºÏöî Î¶¨Ïä§ÌÅ¨ ÏöîÏù∏Îì§ÏùÑ ÏöîÏïΩ]
"""

    def _extract_section(self, text: str, section_name: str) -> str:
        """ÌÖçÏä§Ìä∏ÏóêÏÑú ÌäπÏ†ï ÏÑπÏÖò Ï∂îÏ∂ú"""
        try:
            lines = text.split('\n')
            in_section = False
            section_content = []

            for line in lines:
                if section_name in line and ':' in line:
                    in_section = True
                    continue
                elif in_section and line.startswith('**') and ':' in line:
                    break
                elif in_section:
                    section_content.append(line.strip())

            return ' '.join(section_content).strip() or f"{section_name} Î∂ÑÏÑù Í≤∞Í≥º ÏóÜÏùå"
        except:
            return f"{section_name} Î∂ÑÏÑù Í≤∞Í≥º ÏóÜÏùå"

    def _extract_list(self, text: str, list_name: str) -> List[str]:
        """ÌÖçÏä§Ìä∏ÏóêÏÑú Î¶¨Ïä§Ìä∏ Ï∂îÏ∂ú"""
        try:
            lines = text.split('\n')
            in_section = False
            items = []

            for line in lines:
                if list_name in line and ':' in line:
                    in_section = True
                    continue
                elif in_section and line.startswith('**') and ':' in line:
                    break
                elif in_section and line.strip().startswith('-'):
                    item = line.strip()[1:].strip()
                    if item:
                        items.append(item)

            return items if items else [f"{list_name} Ìï≠Î™© ÏóÜÏùå"]
        except:
            return [f"{list_name} Ìï≠Î™© ÏóÜÏùå"]

    def _determine_risk_level(
        self, risk_indicators: RiskIndicators, correlation_analysis: CorrelationAnalysis, personality: str = "neutral"
    ) -> Tuple[str, bool, float]:
        """ÏµúÏ¢Ö Î¶¨Ïä§ÌÅ¨ Î†àÎ≤® Í≤∞Ï†ï (Ìà¨Ïûê ÏÑ±Ìñ• Í≥†Î†§)"""
        try:
            risk_score = risk_indicators.overall_risk_score
            vix_level = risk_indicators.vix_level
            risk_off_count = len(correlation_analysis.risk_off_indicators)

            # Ìà¨Ïûê ÏÑ±Ìñ•Ïóê Îî∞Î•∏ ÏûÑÍ≥ÑÍ∞í Ï°∞Ï†ï
            if personality == "conservative":
                # Î≥¥ÏàòÏ†Å: Îçî ÎØºÍ∞êÌïòÍ≤å Î¶¨Ïä§ÌÅ¨ Í∞êÏßÄ
                critical_threshold = 70
                high_threshold = 50
                medium_threshold = 30
                vix_critical = 30
                vix_high = 20
                vix_medium = 15
            elif personality == "aggressive":
                # Í≥µÍ≤©Ï†Å: Îçú ÎØºÍ∞êÌïòÍ≤å Î¶¨Ïä§ÌÅ¨ Í∞êÏßÄ
                critical_threshold = 90
                high_threshold = 70
                medium_threshold = 50
                vix_critical = 40
                vix_high = 30
                vix_medium = 25
            else:  # neutral
                # Ï§ëÎ¶ΩÏ†Å: Í∏∞Î≥∏ ÏûÑÍ≥ÑÍ∞í
                critical_threshold = 80
                high_threshold = 60
                medium_threshold = 40
                vix_critical = 35
                vix_high = 25
                vix_medium = 20

            # Î¶¨Ïä§ÌÅ¨ Î†àÎ≤® Í≤∞Ï†ï
            if risk_score >= critical_threshold or vix_level >= vix_critical or risk_off_count >= 3:
                risk_level = "CRITICAL"
                risk_off = True
                confidence = 0.9
            elif risk_score >= high_threshold or vix_level >= vix_high or risk_off_count >= 2:
                risk_level = "HIGH"
                risk_off = True
                confidence = 0.8
            elif risk_score >= medium_threshold or vix_level >= vix_medium or risk_off_count >= 1:
                risk_level = "MEDIUM"
                risk_off = risk_off_count >= 1
                confidence = 0.7
            else:
                risk_level = "LOW"
                risk_off = False
                confidence = 0.6

            return risk_level, risk_off, confidence

        except Exception as e:
            logger.error(f"Î¶¨Ïä§ÌÅ¨ Î†àÎ≤® Í≤∞Ï†ï Ïã§Ìå®: {str(e)}")
            return "UNKNOWN", False, 0.0

    # _generate_recommendations Ìï®Ïàò Ï†úÍ±∞Îê®
    # Ìà¨Ïûê Í∂åÏû•ÏÇ¨Ìï≠ÏùÄ ÎßàÏä§ÌÑ∞ ÏóêÏù¥Ï†ÑÌä∏Í∞Ä Îã¥ÎãπÌïòÎØÄÎ°ú Î¶¨Ïä§ÌÅ¨ ÏóêÏù¥Ï†ÑÌä∏ÏóêÏÑúÎäî Ï†úÍ≥µÌïòÏßÄ ÏïäÏùå

    async def health_check(self) -> Dict[str, Any]:
        """ÏÑúÎπÑÏä§ Ìó¨Ïä§Ï≤¥ÌÅ¨"""
        try:
            # Í∏∞Î≥∏ Îç∞Ïù¥ÌÑ∞ ÏàòÏßë ÌÖåÏä§Ìä∏
            test_data = await self._collect_market_data(7)

            # Î¶¨Ïä§ÌÅ¨ ÏßÄÌëú Í≥ÑÏÇ∞ ÌÖåÏä§Ìä∏
            risk_indicators = self._calculate_risk_indicators(test_data)

            # ÏÉÅÍ¥ÄÍ¥ÄÍ≥Ñ Î∂ÑÏÑù ÌÖåÏä§Ìä∏
            correlation_analysis = self._analyze_correlations(test_data)

            return {
                "data_collection": "ok",
                "risk_calculation": "ok",
                "correlation_analysis": "ok",
                "ai_analysis": "ok" if self.use_ai_analysis else "disabled",
                "test_risk_score": risk_indicators.overall_risk_score,
                "test_correlations": len(correlation_analysis.risk_off_indicators)
            }

        except Exception as e:
            logger.error(f"Ìó¨Ïä§Ï≤¥ÌÅ¨ Ïã§Ìå®: {str(e)}")
            return {
                "data_collection": "error",
                "risk_calculation": "error",
                "correlation_analysis": "error",
                "ai_analysis": "error",
                "error": str(e)
            }
